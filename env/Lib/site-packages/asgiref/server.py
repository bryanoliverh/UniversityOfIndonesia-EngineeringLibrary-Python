import asyncio
import logging
import time
import traceback

logger = logging.getLogger(__name__)


class StatelessServer:
    application_checker_interval = 0.1

    def __init__(self, application, max_applications=1000):
        
        self.application = application
        self.max_applications = max_applications
        
        self.application_instances = {}

    def run(self):
        event_loop = asyncio.get_event_loop()
        asyncio.ensure_future(self.application_checker())
        try:
            event_loop.run_until_complete(self.handle())
        except KeyboardInterrupt:
            logger.info("Exiting due to Ctrl-C/interrupt")

    async def handle(self):
        raise NotImplementedError("You must implement handle()")

    async def application_send(self, scope, message):
      
        raise NotImplementedError("You must implement application_send()")

   

    def get_or_create_application_instance(self, scope_id, scope):

        if scope_id in self.application_instances:
            self.application_instances[scope_id]["last_used"] = time.time()
            return self.application_instances[scope_id]["input_queue"]
 
        while len(self.application_instances) > self.max_applications:
            self.delete_oldest_application_instance()
 
        input_queue = asyncio.Queue()
        application_instance = self.application(scope=scope)

        future = asyncio.ensure_future(
            application_instance(
                receive=input_queue.get,
                send=lambda message: self.application_send(scope, message),
            )
        )
        self.application_instances[scope_id] = {
            "input_queue": input_queue,
            "future": future,
            "scope": scope,
            "last_used": time.time(),
        }
        return input_queue

    def delete_oldest_application_instance(self):


        oldest_time = min(
            details["last_used"] for details in self.application_instances.values()
        )
        for scope_id, details in self.application_instances.items():
            if details["last_used"] == oldest_time:
                self.delete_application_instance(scope_id)
     
                return

    def delete_application_instance(self, scope_id):
       
        details = self.application_instances[scope_id]
        del self.application_instances[scope_id]
        if not details["future"].done():
            details["future"].cancel()

    async def application_checker(self):
      
        while True:
            await asyncio.sleep(self.application_checker_interval)
            for scope_id, details in list(self.application_instances.items()):
                if details["future"].done():
                    exception = details["future"].exception()
                    if exception:
                        await self.application_exception(exception, details)
                    try:
                        del self.application_instances[scope_id]
                    except KeyError:
                        pass

    async def application_exception(self, exception, application_details):
    
        logging.error(
            "Exception inside application: %s\n%s%s",
            exception,
            "".join(traceback.format_tb(exception.__traceback__)),
            "  {}".format(exception),
        )
